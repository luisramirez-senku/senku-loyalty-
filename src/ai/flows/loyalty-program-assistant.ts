
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview A virtual assistant powered by Gemini to answer loyalty program questions and perform actions.
 *
 * - loyaltyProgramAssistant - A function that handles the virtual assistant process.
 * - LoyaltyProgramAssistantInput - The input type for the loyaltyProgramAssistant function.
 * - LoyaltyProgramAssistantOutput - The return type for the loyaltyProgramAssistant function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { db } from "@/lib/firebase/client";
import { collection, doc, getDoc, getDocs, updateDoc, writeBatch } from "firebase/firestore";
import type { Customer, Transaction } from "@/components/app/admin/customer-management";
import type { Reward } from "@/components/app/admin/reward-management";


// Para la demo, obtenemos un cliente específico. En una app real, esto vendría de la sesión del usuario.
const CUSTOMER_ID_DEMO = "bAsz8Nn9EaN5Sg2v3j0K";

const loyaltyProgramDetails = "El programa tiene tres niveles: Bronce (0-4999 pts), Plata (5000-9999 pts) y Oro (10000+ pts). Las recompensas incluyen bebidas gratis, descuentos y ofertas exclusivas.";


// Tool definitions
const getCustomerInfo = ai.defineTool(
    {
      name: 'getCustomerInfo',
      description: 'Obtiene la información del cliente actual, como su nombre, nivel de lealtad, saldo de puntos y su historial de transacciones.',
      inputSchema: z.object({}),
      outputSchema: z.object({
        name: z.string(),
        tier: z.string(),
        points: z.number(),
        history: z.array(z.object({
            id: z.string(),
            date: z.string(),
            description: z.string(),
            points: z.number(),
        })).optional(),
      }),
    },
    async () => {
      const docRef = doc(db, "customers", CUSTOMER_ID_DEMO);
      const docSnap = await getDoc(docRef);
      if (docSnap.exists()) {
        const customer = docSnap.data() as Customer;
        return {
            name: customer.name,
            tier: customer.tier,
            points: customer.points,
            history: customer.history || [],
        }
      }
      throw new Error("Cliente no encontrado.");
    }
);


const getAvailableRewards = ai.defineTool(
    {
        name: 'getAvailableRewards',
        description: 'Obtiene una lista de todas las recompensas disponibles y su costo en puntos.',
        inputSchema: z.object({}),
        outputSchema: z.array(z.object({
            id: z.string(),
            name: z.string(),
            cost: z.number(),
        })),
    },
    async () => {
        const rewardsSnapshot = await getDocs(collection(db, "rewards"));
        if (rewardsSnapshot.empty) {
            return [];
        }
        return rewardsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Reward));
    }
);

const redeemReward = ai.defineTool(
    {
        name: 'redeemReward',
        description: 'Canjea una recompensa para el cliente, descontando el costo de los puntos del cliente.',
        inputSchema: z.object({
            rewardId: z.string().describe('El ID de la recompensa a canjear.'),
        }),
        outputSchema: z.object({
            success: z.boolean(),
            message: z.string(),
            remainingPoints: z.number().optional(),
        }),
    },
    async ({ rewardId }) => {
        const customerRef = doc(db, "customers", CUSTOMER_ID_DEMO);
        const customerSnap = await getDoc(customerRef);

        if (!customerSnap.exists()) {
            return { success: false, message: 'Cliente no encontrado.' };
        }
        const customer = customerSnap.data() as Customer;
        
        const rewardRef = doc(db, "rewards", rewardId);
        const rewardSnap = await getDoc(rewardRef);

        if (!rewardSnap.exists()) {
            return { success: false, message: 'Recompensa no encontrada.' };
        }
        const reward = rewardSnap.data() as Reward;

        if (customer.points < reward.cost) {
            return { success: false, message: `No tienes suficientes puntos. Necesitas ${reward.cost} puntos, pero tienes ${customer.points}.` };
        }
        
        const newTotalPoints = customer.points - reward.cost;
        await updateDoc(customerRef, {
            points: newTotalPoints
        });
        
        return { success: true, message: `¡Has canjeado "${reward.name}" con éxito!`, remainingPoints: newTotalPoints };
    }
);


const LoyaltyProgramAssistantInputSchema = z.object({
  query: z.string().describe('La consulta del usuario sobre el programa de lealtad.'),
});
export type LoyaltyProgramAssistantInput = z.infer<typeof LoyaltyProgramAssistantInputSchema>;

const LoyaltyProgramAssistantOutputSchema = z.object({
  response: z.string().describe('La respuesta a la consulta del usuario, proporcionando información útil y resolviendo cualquier problema.'),
});
export type LoyaltyProgramAssistantOutput = z.infer<typeof LoyaltyProgramAssistantOutputSchema>;

export async function loyaltyProgramAssistant(input: LoyaltyProgramAssistantInput): Promise<LoyaltyProgramAssistantOutput> {
  return loyaltyProgramAssistantFlow(input);
}

const prompt = ai.definePrompt({
  name: 'loyaltyProgramAssistantPrompt',
  input: {schema: LoyaltyProgramAssistantInputSchema},
  output: {schema: LoyaltyProgramAssistantOutputSchema},
  tools: [getCustomerInfo, getAvailableRewards, redeemReward],
  prompt: `Eres un asistente virtual amigable y altamente competente para un programa de lealtad. Tu objetivo es responder las preguntas de los usuarios y resolver problemas comunes relacionados con el programa de lealtad, utilizando las herramientas proporcionadas cuando sea necesario.

  Aquí están los detalles del programa de lealtad:
  ${loyaltyProgramDetails}

  Utiliza las herramientas para obtener información específica del cliente o del programa cuando la necesites para responder. No inventes información sobre puntos, nivel, o recompensas; usa siempre las herramientas para obtener datos precisos.
  
  Si un usuario quiere realizar una acción, como canjear una recompensa, usa la herramienta apropiada y confirma el resultado.
  
  Siempre sé claro, conciso y servicial.

  Ahora, responde a la siguiente consulta del usuario:
  {{{query}}}
  `,
});

const loyaltyProgramAssistantFlow = ai.defineFlow(
  {
    name: 'loyaltyProgramAssistantFlow',
    inputSchema: LoyaltyProgramAssistantInputSchema,
    outputSchema: LoyaltyProgramAssistantOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
